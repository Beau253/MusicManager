# src/music_manager/utils/processes.py

import logging
import os
import subprocess
import threading
from typing import List

# Get the logger for this module.
# It will inherit the configuration from the root logger set up in main.py.
logger = logging.getLogger(__name__)

def run_external_process(command_list: List[str]) -> int:
    """
    Executes an external command, capturing its stdout and stderr streams in
    real-time and passing them to the application's logger.

    This function is essential for getting detailed, real-time feedback from
    external tools like 'onthespot' and 'picard' directly into the unified
    log file.

    Args:
        command_list: A list of strings representing the command and its
                      arguments (e.g., ['picard', '--output', '/music']).

    Returns:
        The integer return code of the process. A return code of 0 typically
        indicates success, while a non-zero value indicates an error.
    """
    if not command_list:
        logger.error("run_external_process was called with an empty command list.")
        return -1

    # Extract the base command name for clear logging
    process_name = os.path.basename(command_list[0])
    
    logger.info(f"Starting external service: {process_name}")
    # Log the full command at the DEBUG level for detailed troubleshooting
    logger.debug(f"Executing command: {' '.join(command_list)}")

    try:
        # Use subprocess.Popen for fine-grained control over the process.
        # - stdout/stderr=subprocess.PIPE: Redirects the output streams so we can capture them.
        # - text=True: Decodes the streams as text using the default encoding.
        # - bufsize=1: Sets line-buffering, so we get output line by line as it happens.
        process = subprocess.Popen(
            command_list,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # --- Real-time Logging with Threads ---
        # We use separate threads to read stdout and stderr without blocking the main
        # application. This allows us to log messages as they are generated by the process.

        def log_stream(stream, log_level):
            """Target function for the threads. Reads a stream line by line and logs it."""
            try:
                # 'iter(stream.readline, "")' will read lines until the stream is closed.
                for line in iter(stream.readline, ''):
                    # Only log non-empty lines to keep the log file clean.
                    if line.strip():
                        # Use the logger instance from the outer scope.
                        # The log message is prefixed with the process name for context.
                        logger.log(log_level, f"[{process_name}] {line.strip()}")
            finally:
                stream.close()

        # Create and start a thread for the standard output stream (logged as INFO)
        stdout_thread = threading.Thread(target=log_stream, args=(process.stdout, logging.INFO))
        stdout_thread.start()

        # Create and start a thread for the standard error stream (logged as ERROR)
        stderr_thread = threading.Thread(target=log_stream, args=(process.stderr, logging.ERROR))
        stderr_thread.start()

        # Wait for the process to complete to get its return code
        return_code = process.wait()

        # Wait for the logging threads to finish reading any remaining buffered output
        stdout_thread.join()
        stderr_thread.join()

        if return_code == 0:
            logger.info(f"External service '{process_name}' finished successfully (Exit Code: 0).")
        else:
            logger.error(f"External service '{process_name}' finished with an error (Exit Code: {return_code}).")
        
        return return_code

    except FileNotFoundError:
        logger.critical(f"Command not found: '{process_name}'. Please ensure it is installed and in the system's PATH.")
        return -1  # Return a specific error code for "command not found"
    except Exception as e:
        logger.critical(f"An unexpected critical error occurred while trying to run '{process_name}': {e}", exc_info=True)
        return -2  # Return a specific error code for unexpected errors